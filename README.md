# 원티드 프리온보딩(wanted_pre_onboarding)

사용 기술: Create React App, Tailwind CSS

## 1. 구현된 컴포넌트 확인 방법

### 1) Vercel로 배포된 페이지

🔗 [링크](http://wanted-pre-onboarding-chi.vercel.app/)

컴포넌트의 작동을 확인해 볼 수 있는 페이지입니다.
필수로 입력해야 하는 props만 입력한 컴포넌트와 선택적으로 입력해도 되는 props까지 모두 입력한 컴포넌트, 총 두 개의 컴포넌트가 기본적으로 출력되어 있습니다.

### 2) 레포지토리 클론

```
git clone https://github.com/Moon-Ga/wanted_pre_onboarding.git
cd wanted_pre_onboarding
npm install
npm start
```

컴포넌트의 `props`를 수정해 보는 등 더 세세하게 작동을 확인해 볼 수 있습니다.

## 2. 폴더 구조

```
📁src
├─ 📁components
│  ├─ Dropdown.js
│  ├─ Input.js
│  ├─ Slider.js
│  ├─ Tab.js
│  └─ Toggle.js
├─ 📁data
│  └─ DropdownData.js
├─ App.css
├─ App.js
└─ index.js
```

- 모든 컴포넌트는 components 폴더에 모아두었습니다.
- Dropdown 컴포넌트에서 사용되는 드롭다운 리스트 데이터의 코드 길이가 길기 때문에 data 폴더의 DropdownData.js로 분리하였습니다.
- 상태와 로직을 분리하여 HOC를 활용할 수도 있었으나 당장엔 적용하지 안았습니다.

## 3. 구현 방향성

- 모든 컴포넌트들은 상황에 맞게 구현해야 합니다.
- 특정한 상황이 주어지지 않았기에 우선은 재사용성을 고려하며 구현하였습니다.
- 컴포넌트 동작에 필요한 함수와 변수들을 여러 개로 분리하고 의미 있는 이름을 붙여줌으로써 각각이 어떤 역할을 하는지 파악하기 쉽도록 하였습니다.
- 불필요한 렌더링을 최소화 하려 노력했습니다.
- 더 좋은 코드나 리팩토링 아이디어가 떠오르면 즉각적으로 이를 반영해보며 코드를 개선해 나갔습니다.

## 4. 컴포넌트 별 설명

※ Props에서 💡이 붙은 것은 반드시 입력해줘야 합니다.

### 1) Toggle

| Props            | Default | Type    | Description                                                                                     |
| ---------------- | ------- | ------- | ----------------------------------------------------------------------------------------------- |
| `usage`💡        |         | string  | 버튼에 고유성을 부여합니다. 버튼이 한 화면에 여러 개일 때 반드시 각각 다르게 설정해줘야 합니다. |
| `isToggled`💡    |         |         | 버튼에 사용될 `state`입니다.                                                                    |
| `setIsToggled`💡 |         |         | 버튼에 사용될 `state`를 변경할 `setState`입니다.                                                |
| `label`          |         | string  | 버튼의 좌와 우에 들어갈 단어의 배열입니다.                                                      |
| `disabled`       | `true`  | boolean | 버튼의 활성화 여부를 설정합니다.                                                                |

- 구현 설명

  - 토글 버튼에 대한 state는 버튼의 내부가 아닌 버튼을 사용하는 컴포넌트에서 props로 보내서 활용해야 한다고 생각하여 App.js에서 state를 작성하였습니다.
  - `checkbox` 타입의 `input` 태그를 사용하였으며, 체크 박스의 체크 여부(boolean)를 `setIsToggled`로 `isToggled` state에 set 해주었습니다. 따라서, 토글 버튼을 사용하는 컴포넌트에선 이 state를 활용하여 토글 버튼의 상태를 판단할 수 있습니다.
  - 스타일링을 위해 `label` 태그를 부착해주었고, `input` 태그는 `display: none`으로 숨겼습니다.
  - transition으로 애니메이션을 구현하였습니다.

- 어려웠거나 고민했던 점들과 해결 방법

  - `label`태그와 `input` 태그를 연결하기 위해선 `label`의 `htmlFor`과 `input`의 `id` 프로퍼티를 일치시켜줘야 합니다. 따라서 처음엔 이들을 `'toggle'`로 설정해줬었는데, 화면에 버튼이 하나만 있을 때에는 아무런 문제가 없었으나 두 개 이상이 될 경우 `label`이 모든 `input` 태그를 조작하게 되는 버그가 발생하였습니다. 이를 해결하기 위해 `usage`라는 props를 만들어 각각의 `label`과 `input`에 고유성을 부여했습니다.
  - 버튼에 대한 state가 버튼 외부의 컴포넌트에 존재하다 보니, 버튼의 state가 변경되면 컴포넌트 전체가 재렌더 되는 현상이 발생하였습니다. 이를 해결하기 위해 많은 고민을 했으나 이렇다 할 방법은 생각해내지 못했는데, hoc나 wrapper를 활용하는 방법도 시도해볼 수 있다고 생각했습니다. 이에 대해선 계속해서 고민해 봐야 할 것 같습니다.

### 2) Tab

| Props    | Default     | Type  | Description                               |
| -------- | ----------- | ----- | ----------------------------------------- |
| `tabs`💡 | `[1, 2, 3]` | array | 탭으로 나타날 내용을 설정하는 배열입니다. |

- 구현 설명

  - props로 전달 받은 `tabs` 배열에 map 메서드를 사용하여 화면에 출력하였습니다.
  - 선택된 탭을 판단하기 위한 `selected` state를 설정하였으며 이는 `tabs` 배열 내 선택된 탭의 index를 의미합니다.
  - `selected` state와 map 메서드로 출력된 탭의 index가 일치하면 추가적인 CSS가 적용되도록 구현하여 탭이 선택되었음을 표현하였습니다. 이는 `switchTab` 함수를 만들어 각각의 탭에 onClickidx를 인자로 받음으로써
  - 탭 아래의 slider를 구현하기 위해 탭의 갯수에 따른 width의 비율이 필요했고, `tabWidth` 변수를 만들어 이를 판단하였습니다.
  - slider에 애니메이션을 부여하기 위해 style의 `left` 프로퍼티를 활용하기로 생각했습니다. 탭이 선택될 때마다 `sliderRef`로 `left` 프로퍼티가 변경되며, transition으로 인해 애니메이션이 발생합니다.
  - 탭의 길이가 4개, 6개, 8개가 될 때 마다 각 탭의 크기가 작아지도록 구현했습니다.

- 어려웠거나 고민했던 점들과 해결 방법

  - slider의 크기를 판단하거나 이에 애니메이션을 부여하려 할 때, 각 탭이 선택될 때의 `width`와 `left` 프로퍼티가 동적으로 계산되도록 template literal('``')을 활용하려 했습니다. 하지만 Tailwind CSS는 작동 설계 상 `left-${left}`와 같은 동적인 계산이 불가능하고, 반드시 `left-10`처럼 완전한 수치가 주어져야 했기에 이를 활용할 수 없었습니다. 따라서 모든 상황에 따른 left 수치를 전부 제공해주거나 다른 CSS 기법을 활용해야 했고, 결론적으로 React의 `style` 어트리뷰트를 활용하였습니다. [React 공식 문서](https://ko.reactjs.org/docs/dom-elements.html#style)에 따르면, 이는 일반적인 스타일링으로 권장되진 않으나 렌더링 시점에 동적으로 계산된 스타일을 추가하기 위해 사용할 수 있다고 하였으므로 현재의 상황에 적합하다고 생각했습니다.

### 3) Slider

| Props           | Default | Type   | Description                                          |
| --------------- | ------- | ------ | ---------------------------------------------------- |
| `value`💡       |         |        | 슬라이더에 사용될 state입니다.                       |
| `setValue`💡    |         |        | 슬라이더에 사용될 `state`를 변경할 `setState`입니다. |
| `min`💡         | `0`     | number | 최소값을 설정합니다.                                 |
| `max`💡         | `100`   | number | 최대값을 설정합니다.                                 |
| `step`💡        | `1`     | number | 슬라이더 한 틱의 값을 설정합니다.                    |
| `buttonCount`💡 | `5`     | number | 슬라이더 하단의 버튼을 몇 개로 나눌 지 설정합니다.   |

- 구현 설명

  - 슬라이더에 대한 state는 슬라이더의 내부가 아닌 슬라이더를 사용하는 컴포넌트에서 props로 보내서 활용해야 한다고 생각하여 App.js에서 state를 작성하였습니다.
  - min, max, buttonCount를 활용한 계산식을 만들어 useEffect로 슬라이더 하단의 버튼들이 될 `buttons`배열을 구현하였습니다.
  - 슬라이더에 CSS를 적용하기 위해 본래의 `input` 태그의 요소들에 `appearance: none`을 주었습니다. range 타입의 `input` 태그는 스타일링을 하기 위해선 `input[type="range"]::-webkit-slider-runnable-track`과 같은 user-agent shadow DOM을 수정해야 하므로 App.css에서 이들에 대한 스타일링을 적용하였습니다.
  - webkit, moz, ms 기반 브라우저들에 대한 스타일링을 모두 명시해줌으로써 크로스 브라우징을 고려하였습니다.
  - 슬라이더의 value에 따라 미려하게 색이 칠해지도록 하기 위해 `ratio`변수를 만들었습니다. 이 변수는 value 대비 슬라이더가 칠해져야 하는 비율을 계산하여 동적으로 변화하는 `liner-gradient` 수치이며, 이를 React `style` 어트리뷰트에 적용하였습니다.
  - 슬라이더 내의 버튼들에 따른 분기점들 역시 `ratio`변수와 `style` 어트리뷰트를 활용하여 칠해지도록 구현했습니다.

- 어려웠거나 고민했던 점들과 해결 방법

  - `input` 태그 자체를 스타일링 할 수 없다 보니 CSS 적용에 어려움이 많았습니다. range 타입의 `input`을 사용하지 말고 `div`나 `span` 등으로 슬라이더를 구현하는 것도 생각해봤지만, `input`을 사용하고 싶어 이를 스타일링하는 방법을 탐구했습니다. 그 결과 슬라이더를 구현할 수 있었으나, 이 슬라이더는 다양한 스타일링 적용이나 반응형 스타일링이 어려울 것으로 판단되어, 나중에는 직접 슬라이더를 구현해보는 것도 나쁘지 않겠다고 생각했습니다.
  - 슬라이더의 value가 바뀔 때마다 슬라이더가 재렌더가 되고, 함수들이 재실행됨에 따라 성능의 저하가 있을 것으로 판단됐습니다. 이를 방지하기 위해 함수에 조건을 걸어보기, 함수 분리하기, 불필요한 함수 삭제하기 등 다양한 시도를 해봤으나, 몇 번의 리팩토링 끝에도 이렇다 할 방법을 찾아내진 못하였습니다. 따라서 추후 이에 대한 고민을 계속 해볼 예정입니다.

### 4) Dropdown

| Props           | Default            | Type   | Description                                                |
| --------------- | ------------------ | ------ | ---------------------------------------------------------- |
| `selected`💡    |                    |        | 드롭다운에 사용될 state입니다.                             |
| `setSelected`💡 |                    |        | 드롭다운에 사용될 `state`를 변경할 `setState`입니다.       |
| `list`💡        |                    | array  | 드롭다운에 들어갈 내용을 설정하는 배열입니다.              |
| `placeholder`   | `'Select an Item'` | string | 드롭다운을 펼치기 위한 `input`의 placeholder를 설정합니다. |
| `direction`     | `'down'`           | string | 드롭다운을 펼쳤을 때, 펼쳐질 방향을 설정합니다.            |

- 구현 설명

  - 드롭다운에 대한 state는 드롭다운의 내부가 아닌 드롭다운을 사용하는 컴포넌트에서 props로 보내서 활용해야 한다고 생각하여 App.js에서 state를 작성하였습니다.
  - 가독성을 위해 드롭다운의 리스트에서 사용될 내용은 data 폴더로 분리하여 관리하였습니다.
  - `filter()`메서드와 `indexOf()` 메서드를 활용하여 리스트 필터링을 구현하였습니다.
  - 드롭다운 리스트를 펼치기 위한 요소는 `input`을 활용하였으며, 드롭다운 리스트 자체는 `div`와 `input`을 메인으로 활용하였습니다.
  - 드롭다운 리스트를 펼치면 검색창에 autofocus가 되도록 구현하였습니다.
  - useEffect와 `addEventListener()` 메서드를 활용하여 드롭다운 리스트 바깥을 클릭하면 리스트가 닫히도록 구현하였습니다.
  - 드롭다운이 아래로 펼쳐질 공간이 부족한 경우를 고려하여 `direction`이라는 props를 만들어 위로 펼칠 수도 있도록 구현하였습니다.

- 어려웠거나 고민했던 점들과 해결 방법

  - 드롭다운 리스트 바깥을 클릭했을 때 리스트가 닫히도록 구현하는 것이 어려웠습니다. 검색창 역할을 하는 `input` 태그에 `onBlur`를 줌으로써 검색창에서 포커스가 풀리면 리스트가 닫히도록 구현해보려 했으나, 아이템을 선택하려는 순간 창이 닫혀버려 선택이 되지 않는 현상으로 인해 실패하였습니다. 다양한 방법을 찾아보던 중 `contains()` DOM element 메서드를 알게 되어 클릭된 대상이 `input`창을 담고 있는지를 판단하는 함수를 만들 수 있었고, 이를 useEffect로 document에 클릭 이벤트 리스너로 추가하고 제거하도록 구현함으로써 문제를 해결할 수 있었습니다.

### 5) Input

| Props                | Default | Type | Description                                                |
| -------------------- | ------- | ---- | ---------------------------------------------------------- |
| `setInputEmail`💡    |         |      | Email input에 사용될 `state`를 변경할 `setState`입니다.    |
| `setInputPassword`💡 |         |      | Password input에 사용될 `state`를 변경할 `setState`입니다. |

- 구현 설명

  - 인풋들에 대한 state는 인풋의 내부가 아닌 인풋을 사용하는 컴포넌트에서 props로 보내서 활용해야 한다고 생각하여 App.js에서 state를 작성하였습니다.
  - 실시간으로 Email과 Password의 유효성을 나타내는 `isValid` state를 만들었으며, 이는 `onInputChange` 함수에 의해 변화합니다.
  - `input` 태그의 `required`와 `pattern` 어트리뷰트를 활용하여 유효성 검사가 이루어지도록 구현하였습니다. 이 유효성 검사는 `onInputChange` 함수 내부에서 `e.target.validity.valid`로 접근하였습니다.
  - `input`에서 포커스가 풀렸을 때, 유효성 검사가 통과되지 않았을 시 경고를 띄우기 위한 `invalidAlert` state를 만들었으며, 이는 `onInputBlur`함수에 의해 변화합니다. 만약 `onBlur` 때 `isValid`가 false라면 경고가 표시됩니다.
  - 패스워드 입력창에서 눈 모양을 누르면 `input`의 타입이 password인지 text인지에 따라 서로 변하도록 함수를 구현하였습니다.

- 어려웠거나 고민했던 점들과 해결 방법

  - 코드가 깔끔하게 짜여지지 않고 성능적으로 저하되는 부분들이 있을 것 같아 리팩토링을 지속적으로 시도했음에도 만족스럽지 못했습니다. 상태와 로직을 분리하거나 로직 자체를 수정함으로써 개선할 수 있을 것으로 생각되는데 추후 좋은 방법이 떠오르면 수정해볼 예정입니다.
